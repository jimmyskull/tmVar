# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package BioC_full;
use base qw(Exporter);
use base qw(DynaLoader);
package BioC_fullc;
bootstrap BioC_full;
package BioC_full;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package BioC_full;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package BioC_full;

*write = *BioC_fullc::write;
*__lshift__ = *BioC_fullc::__lshift__;

############# Class : BioC_full::Node ##############

package BioC_full::Node;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_Node(@_);
    bless $self, $pkg if defined($self);
}

*swig_refid_get = *BioC_fullc::Node_refid_get;
*swig_refid_set = *BioC_fullc::Node_refid_set;
*swig_role_get = *BioC_fullc::Node_role_get;
*swig_role_set = *BioC_fullc::Node_role_set;
*write = *BioC_fullc::Node_write;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_Node($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::Relation ##############

package BioC_full::Relation;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
*swig_id_get = *BioC_fullc::Relation_id_get;
*swig_id_set = *BioC_fullc::Relation_id_set;
*swig_infons_get = *BioC_fullc::Relation_infons_get;
*swig_infons_set = *BioC_fullc::Relation_infons_set;
*swig_nodes_get = *BioC_fullc::Relation_nodes_get;
*swig_nodes_set = *BioC_fullc::Relation_nodes_set;
*num_nodes = *BioC_fullc::Relation_num_nodes;
*refid = *BioC_fullc::Relation_refid;
*role = *BioC_fullc::Relation_role;
*add_node = *BioC_fullc::Relation_add_node;
*write = *BioC_fullc::Relation_write;
*clear = *BioC_fullc::Relation_clear;
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_Relation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_Relation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::Location ##############

package BioC_full::Location;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_Location(@_);
    bless $self, $pkg if defined($self);
}

*swig_offset_get = *BioC_fullc::Location_offset_get;
*swig_offset_set = *BioC_fullc::Location_offset_set;
*swig_length_get = *BioC_fullc::Location_length_get;
*swig_length_set = *BioC_fullc::Location_length_set;
*write = *BioC_fullc::Location_write;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_Location($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::Annotation ##############

package BioC_full::Annotation;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
*swig_id_get = *BioC_fullc::Annotation_id_get;
*swig_id_set = *BioC_fullc::Annotation_id_set;
*swig_infons_get = *BioC_fullc::Annotation_infons_get;
*swig_infons_set = *BioC_fullc::Annotation_infons_set;
*swig_locations_get = *BioC_fullc::Annotation_locations_get;
*swig_locations_set = *BioC_fullc::Annotation_locations_set;
*swig_text_get = *BioC_fullc::Annotation_text_get;
*swig_text_set = *BioC_fullc::Annotation_text_set;
*num_segments = *BioC_fullc::Annotation_num_segments;
*offset = *BioC_fullc::Annotation_offset;
*length = *BioC_fullc::Annotation_length;
*add_location = *BioC_fullc::Annotation_add_location;
*write = *BioC_fullc::Annotation_write;
*clear = *BioC_fullc::Annotation_clear;
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_Annotation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_Annotation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::Sentence ##############

package BioC_full::Sentence;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
*swig_infons_get = *BioC_fullc::Sentence_infons_get;
*swig_infons_set = *BioC_fullc::Sentence_infons_set;
*swig_offset_get = *BioC_fullc::Sentence_offset_get;
*swig_offset_set = *BioC_fullc::Sentence_offset_set;
*swig_text_get = *BioC_fullc::Sentence_text_get;
*swig_text_set = *BioC_fullc::Sentence_text_set;
*swig_annotations_get = *BioC_fullc::Sentence_annotations_get;
*swig_annotations_set = *BioC_fullc::Sentence_annotations_set;
*swig_relations_get = *BioC_fullc::Sentence_relations_get;
*swig_relations_set = *BioC_fullc::Sentence_relations_set;
*write = *BioC_fullc::Sentence_write;
*clear = *BioC_fullc::Sentence_clear;
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_Sentence(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_Sentence($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::Passage ##############

package BioC_full::Passage;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
*swig_infons_get = *BioC_fullc::Passage_infons_get;
*swig_infons_set = *BioC_fullc::Passage_infons_set;
*swig_offset_get = *BioC_fullc::Passage_offset_get;
*swig_offset_set = *BioC_fullc::Passage_offset_set;
*swig_text_get = *BioC_fullc::Passage_text_get;
*swig_text_set = *BioC_fullc::Passage_text_set;
*swig_sentences_get = *BioC_fullc::Passage_sentences_get;
*swig_sentences_set = *BioC_fullc::Passage_sentences_set;
*swig_annotations_get = *BioC_fullc::Passage_annotations_get;
*swig_annotations_set = *BioC_fullc::Passage_annotations_set;
*swig_relations_get = *BioC_fullc::Passage_relations_get;
*swig_relations_set = *BioC_fullc::Passage_relations_set;
*write = *BioC_fullc::Passage_write;
*clear = *BioC_fullc::Passage_clear;
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_Passage(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_Passage($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::Document ##############

package BioC_full::Document;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
*swig_id_get = *BioC_fullc::Document_id_get;
*swig_id_set = *BioC_fullc::Document_id_set;
*swig_infons_get = *BioC_fullc::Document_infons_get;
*swig_infons_set = *BioC_fullc::Document_infons_set;
*swig_passages_get = *BioC_fullc::Document_passages_get;
*swig_passages_set = *BioC_fullc::Document_passages_set;
*swig_relations_get = *BioC_fullc::Document_relations_get;
*swig_relations_set = *BioC_fullc::Document_relations_set;
*write = *BioC_fullc::Document_write;
*clear = *BioC_fullc::Document_clear;
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_Document(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_Document($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::Collection ##############

package BioC_full::Collection;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
*swig_source_get = *BioC_fullc::Collection_source_get;
*swig_source_set = *BioC_fullc::Collection_source_set;
*swig_date_get = *BioC_fullc::Collection_date_get;
*swig_date_set = *BioC_fullc::Collection_date_set;
*swig_key_get = *BioC_fullc::Collection_key_get;
*swig_key_set = *BioC_fullc::Collection_key_set;
*swig_infons_get = *BioC_fullc::Collection_infons_get;
*swig_infons_set = *BioC_fullc::Collection_infons_set;
*swig_documents_get = *BioC_fullc::Collection_documents_get;
*swig_documents_set = *BioC_fullc::Collection_documents_set;
*write = *BioC_fullc::Collection_write;
*clear = *BioC_fullc::Collection_clear;
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_Collection(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_Collection($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::Connector_libxml ##############

package BioC_full::Connector_libxml;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_Connector_libxml(@_);
    bless $self, $pkg if defined($self);
}

*swig_dtd_get = *BioC_fullc::Connector_libxml_dtd_get;
*swig_dtd_set = *BioC_fullc::Connector_libxml_dtd_set;
*read = *BioC_fullc::Connector_libxml_read;
*write = *BioC_fullc::Connector_libxml_write;
*start_read = *BioC_fullc::Connector_libxml_start_read;
*read_next = *BioC_fullc::Connector_libxml_read_next;
*start_write = *BioC_fullc::Connector_libxml_start_write;
*end_write = *BioC_fullc::Connector_libxml_end_write;
*from_XML = *BioC_fullc::Connector_libxml_from_XML;
*getAttribute = *BioC_fullc::Connector_libxml_getAttribute;
*to_XML = *BioC_fullc::Connector_libxml_to_XML;
*setAttribute = *BioC_fullc::Connector_libxml_setAttribute;
*parse_error = *BioC_fullc::Connector_libxml_parse_error;
*getDocument = *BioC_fullc::Connector_libxml_getDocument;
*getValue = *BioC_fullc::Connector_libxml_getValue;
*write_next = *BioC_fullc::Connector_libxml_write_next;
*endElement = *BioC_fullc::Connector_libxml_endElement;
*startElement = *BioC_fullc::Connector_libxml_startElement;
*writeAttribute = *BioC_fullc::Connector_libxml_writeAttribute;
*writeElement = *BioC_fullc::Connector_libxml_writeElement;
*swig_xml_doc_get = *BioC_fullc::Connector_libxml_xml_doc_get;
*swig_xml_doc_set = *BioC_fullc::Connector_libxml_xml_doc_set;
*swig_reader_get = *BioC_fullc::Connector_libxml_reader_get;
*swig_reader_set = *BioC_fullc::Connector_libxml_reader_set;
*swig_writer_get = *BioC_fullc::Connector_libxml_writer_get;
*swig_writer_set = *BioC_fullc::Connector_libxml_writer_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_Connector_libxml($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::Node_Converter ##############

package BioC_full::Node_Converter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
*convert = *BioC_fullc::Node_Converter_convert;
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_Node_Converter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_Node_Converter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::nodV ##############

package BioC_full::nodV;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_nodV(@_);
    bless $self, $pkg if defined($self);
}

*size = *BioC_fullc::nodV_size;
*empty = *BioC_fullc::nodV_empty;
*clear = *BioC_fullc::nodV_clear;
*push = *BioC_fullc::nodV_push;
*pop = *BioC_fullc::nodV_pop;
*get = *BioC_fullc::nodV_get;
*set = *BioC_fullc::nodV_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_nodV($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::locV ##############

package BioC_full::locV;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_locV(@_);
    bless $self, $pkg if defined($self);
}

*size = *BioC_fullc::locV_size;
*empty = *BioC_fullc::locV_empty;
*clear = *BioC_fullc::locV_clear;
*push = *BioC_fullc::locV_push;
*pop = *BioC_fullc::locV_pop;
*get = *BioC_fullc::locV_get;
*set = *BioC_fullc::locV_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_locV($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::stcV ##############

package BioC_full::stcV;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_stcV(@_);
    bless $self, $pkg if defined($self);
}

*size = *BioC_fullc::stcV_size;
*empty = *BioC_fullc::stcV_empty;
*clear = *BioC_fullc::stcV_clear;
*push = *BioC_fullc::stcV_push;
*pop = *BioC_fullc::stcV_pop;
*get = *BioC_fullc::stcV_get;
*set = *BioC_fullc::stcV_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_stcV($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::antV ##############

package BioC_full::antV;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_antV(@_);
    bless $self, $pkg if defined($self);
}

*size = *BioC_fullc::antV_size;
*empty = *BioC_fullc::antV_empty;
*clear = *BioC_fullc::antV_clear;
*push = *BioC_fullc::antV_push;
*pop = *BioC_fullc::antV_pop;
*get = *BioC_fullc::antV_get;
*set = *BioC_fullc::antV_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_antV($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::strV ##############

package BioC_full::strV;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_strV(@_);
    bless $self, $pkg if defined($self);
}

*size = *BioC_fullc::strV_size;
*empty = *BioC_fullc::strV_empty;
*clear = *BioC_fullc::strV_clear;
*push = *BioC_fullc::strV_push;
*pop = *BioC_fullc::strV_pop;
*get = *BioC_fullc::strV_get;
*set = *BioC_fullc::strV_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_strV($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::psgV ##############

package BioC_full::psgV;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_psgV(@_);
    bless $self, $pkg if defined($self);
}

*size = *BioC_fullc::psgV_size;
*empty = *BioC_fullc::psgV_empty;
*clear = *BioC_fullc::psgV_clear;
*push = *BioC_fullc::psgV_push;
*pop = *BioC_fullc::psgV_pop;
*get = *BioC_fullc::psgV_get;
*set = *BioC_fullc::psgV_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_psgV($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::rltV ##############

package BioC_full::rltV;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_rltV(@_);
    bless $self, $pkg if defined($self);
}

*size = *BioC_fullc::rltV_size;
*empty = *BioC_fullc::rltV_empty;
*clear = *BioC_fullc::rltV_clear;
*push = *BioC_fullc::rltV_push;
*pop = *BioC_fullc::rltV_pop;
*get = *BioC_fullc::rltV_get;
*set = *BioC_fullc::rltV_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_rltV($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::docV ##############

package BioC_full::docV;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_docV(@_);
    bless $self, $pkg if defined($self);
}

*size = *BioC_fullc::docV_size;
*empty = *BioC_fullc::docV_empty;
*clear = *BioC_fullc::docV_clear;
*push = *BioC_fullc::docV_push;
*pop = *BioC_fullc::docV_pop;
*get = *BioC_fullc::docV_get;
*set = *BioC_fullc::docV_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_docV($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : BioC_full::strM ##############

package BioC_full::strM;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( BioC_full );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = BioC_fullc::new_strM(@_);
    bless $self, $pkg if defined($self);
}

*size = *BioC_fullc::strM_size;
*empty = *BioC_fullc::strM_empty;
*clear = *BioC_fullc::strM_clear;
*get = *BioC_fullc::strM_get;
*set = *BioC_fullc::strM_set;
*del = *BioC_fullc::strM_del;
*has_key = *BioC_fullc::strM_has_key;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        BioC_fullc::delete_strM($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package BioC_full;

*bioc_dtd = *BioC_fullc::bioc_dtd;
*default_dtd = *BioC_fullc::default_dtd;
1;
